---
title: CORS--跨域资源共享
tags:
  - 跨域问题
  - cors
  - 资源共享
  - node.js
categories:
  - JavaScript基础
abbrlink: 9f59301e
date: 2024-08-11 22:04:52
updated: 2024-08-12 23:00:00
description: 本文介绍浏览器对跨域访问资源的限制，以及解决方案
sticky: 1
swiper_index: 1
cover: https://tuchuang.voooe.cn/images/2024/08/11/shawu_3840x2880.webp
---

# 域（源）

&nbsp;&nbsp;&nbsp;&nbsp;由域名、协议、端口号三部分组成

# 跨域的定义

&nbsp;&nbsp;&nbsp;&nbsp;一个域向另一个域的服务器请求数据, 跨域也称跨源（Origin）, 一般根据http/https请求中Origin判断

# 跨域问题

&nbsp;&nbsp;&nbsp;&nbsp;浏览器出于安全考虑，基于同源策略，限制js代码中<abbr title="XMLHttpRequest">XHR</abbr>对象和[Fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)对跨域资源的访问。默认情况下，不限制js发送请求，但限制js接收不合规的响应。

&nbsp;&nbsp;&nbsp;&nbsp;**注：浏览器仅进行简单的对比判断，域名、协议、端口号必须完全一致，不接受域名重定向或者同一主机的不同
域名，例如localhost和127.0.0.1会判断为不同域名。**

# 解决方案

&nbsp;&nbsp;&nbsp;&nbsp;根据跨域问题的定义，可以考虑到以下两种方式：

- Jsonp方式：不使用任何需要借助XHR对象或Fetch API的工具，而是通过向html中动态插入包含请求api的script标签的方式发送请求(GET)请求，由服务端发送Jsonp类型数据给请求方。

- CORS机制：通过在跨域服务器的响应标头中插入包含请求源域名的`Access-Control-Allow-Origin`字段的方式，来允许浏览器获取该跨域资源。

## Jsonp方式

&nbsp;&nbsp;&nbsp;&nbsp;该方式需要客户端提供回调函数作为请求参数,且服务器端必须支持以<abbr title="Json with Padding">Jsonp</abbr>形式返回响应。本质上是返回携带json数据的js代码片段给客户端浏览器执行，该代码片段中的内容大致为：将请求数据作为形参传入给定的回调函数供浏览器执行，因此，该回调函数是由请求方定义的，并需要服务器提供数据作为参数，以便在回调函数中对数据进行处理。
&nbsp;&nbsp;&nbsp;&nbsp;例如要从`http://example.com/getData`获取数据，并希望使用`handleData`作为回调函数：

```JavaScript
<script>
    function handleData(data) {
        console.log(data);
    }
</script>
<script src="http://example.com/getData?callback=handleData"></script>
```

&nbsp;&nbsp;&nbsp;&nbsp;支持传输jsonp类型数据的跨域服务器可能会返回如下数据:

```JavaScript
handleData({ 'name': 'Alice', 'age': 30 });
```

&nbsp;&nbsp;&nbsp;&nbsp;**注：服务器返回的是一个函数调用的表达式，而不是函数本身或函数的定义。**

### jQuery提供jsonp类型请求

&nbsp;&nbsp;&nbsp;&nbsp;jQuery仅仅是对上面介绍的方式进行了包装，原理是一样的。

```JavaScript
$.ajax({
  type: "get",
  url: "http://example.com/getData",
  data: { // 查询参数
    callback: handleData,
    param: ...,
  },
  dataType: "jsonp", // 必须指明jsonp（默认请求json类型）
  success: function (data) {
    console.log(data);
  },
});
```

### 缺点

- 只能使用 GET 请求：由于 JSONP 是通过 script 标签实现的，它只能使用 GET 请求，而不能使用 POST、PUT 等其他 HTTP 方法。
- 安全性问题：JSONP 会执行从服务器返回的任意 JavaScript 代码，因此存在一定的安全风险。攻击者可能通过诱使你加载恶意脚本来进行 XSS（跨站脚本攻击）。

## CORS机制

&nbsp;&nbsp;&nbsp;&nbsp; CORS 通过 HTTP 请求头的方式，允许服务器声明哪些源可以访问它的资源，以及允许哪些类型的请求（GET、POST、PUT 等）。浏览器在请求时会自动处理这些头信息，并根据服务器的响应决定是否允许跨域请求。

### 简单请求

&nbsp;&nbsp;&nbsp;&nbsp;对于简单请求， CORS 机制直接通过两个 HTTP 头来控制访问：

- Origin: 由浏览器自动添加到请求中，表示发起请求的源（协议 + 域名 + 端口）。
- Access-Control-Allow-Origin: 由服务器在响应中返回，指明允许哪些源访问资源。

&nbsp;&nbsp;&nbsp;&nbsp;例如，浏览器发起如下请求：

```http
GET /data HTTP/1.1
Host: api.example.com
Origin: http://mywebsite.com
```

&nbsp;&nbsp;&nbsp;&nbsp;服务器的响应：

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://mywebsite.com
```

&nbsp;&nbsp;&nbsp;&nbsp;如果服务器响应的`Access-Control-Allow-Origin` 包含发起请求的源（如 <http://mywebsite.com>），浏览器就允许这个跨域请求并将数据传递给 JavaScript 代码。

### 2. 预检请求（Preflight Request）

&nbsp;&nbsp;&nbsp;&nbsp;对于非简单请求（例如，带有自定义头信息的 POST 请求），浏览器会在实际请求前发送一个预检请求，目的是确认服务器是否允许这种跨域请求。
&nbsp;&nbsp;&nbsp;&nbsp;预检请求通常是一个 OPTIONS 请求，类似如下：

```http
OPTIONS /data HTTP/1.1
Host: api.example.com
Origin: http://mywebsite.com
Access-Control-Request-Method: POST
```

&nbsp;&nbsp;&nbsp;&nbsp;服务器响应：

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://mywebsite.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type
```

&nbsp;&nbsp;&nbsp;&nbsp;如果服务器响应允许请求的方法和头信息，浏览器才会发送实际的请求。

### 3. 其他重要的CORS头信息

- Access-Control-Allow-Credentials：是否允许发送凭据（如 cookies、HTTP 认证信息）。
- Access-Control-Expose-Headers：指定哪些响应头可以在浏览器中访问。
- Access-Control-Max-Age：指定预检请求的结果可以缓存多长时间。

### CORS 的作用

&nbsp;&nbsp;&nbsp;&nbsp;CORS 通过控制浏览器行为来防止不受信任的跨域请求，避免可能的安全风险。它允许服务器灵活地指定允许的跨域资源访问规则，从而使得 Web 应用能够安全地跨域获取资源。

### 总结

&nbsp;&nbsp;&nbsp;&nbsp;CORS 是一种标准化的机制，允许服务器通过 HTTP 头来控制哪些外部域可以访问其资源，从而在提升跨域请求灵活性的同时，保持对跨域请求的安全性控制。

### NodeJs实现支持CORS的api

&nbsp;&nbsp;&nbsp;&nbsp;下面将在跨域服务器后端使用express模块提供的http/https服务监听服务器3000端口上的路由/api/users，收到请求后返回携带`Access-Control-Allow-Headers:*`标头的响应信息以允许任意源的js代码获取数据。

```JavaScript
const fs = require("fs");
const path = require("path");
const express = require("express");
const cors = require("cors");
const server = express();
server.use(cors());
server.use(express.static(path.join(__dirname, "public")));
server.get("/api/users", (req, res) => {
  fs.readFile(path.join(__dirname, "data/users.json"), (err, data) => {
    res.send(data.toString());
  });
});
// 访问其他路由时
server.all("*", (req, res) => {
  res.status(404);
  res.send("你要访问的资源路径不存在");
});
server.listen(3000, () => {
  console.log("Web 服务已启动");
});
```

&nbsp;&nbsp;&nbsp;&nbsp;第6行表示允许来自任意源的跨域请求（即添加了`Access-Control-Allow-Origin:*`。第7行表示提供静态文件服务，即将public文件夹下的所有文件挂载到域名的根路由上，可用于模拟public下的前端服务和api在同一个源的情况。第8行表示当本服务器收到发往路由/api/users上的请求时，读取data/users.json文件后将内容返回给请求方。

> 实际生产模式下，几乎所有的资源都是通过http/https协议访问的，对应默认端口号为80/443，但是同一个端口无法既提供网页服务（如<abbr title="http://example.com:80">http://example.com</abbr>）又提供api（如<abbr title="http://example.com:80/api">http://example.com/api</abbr>），这就必然会导致跨域问题，也不存在同源的情况了。目前主流的解决方案是，将默认发往80/443端口上指定路由的http/https请求转发到目标api的源端口上，这也称为反向代理。优点是：1.在前端（发送请求方）看来，网站和api是同源的（http、example.com以及默认的80）；2. 隐藏了api的源端口，降低收到直接攻击的风险。

&nbsp;&nbsp;&nbsp;&nbsp;当然，大部分情况下，提供数据的api并不是我们自己的，且该api的提供方也并不总是愿意在响应头上加上相关字段，因此，上面这种方式仅限于自己提供api的情况。但又因为跨域问题仅仅是限制浏览器端的js，因此，也可以在自己的服务器后端使用node.js提供一个专属api，用于转发前端的跨域请求和目标服务器的响应，这样一来，浏览器接收跨域资源的决定权就在我们自己手里了。实现方法和上面的几乎一致，仅仅是将获取数据的方式由原来的从本地读取改为向目标服务器发送请求获取。

&nbsp;&nbsp;&nbsp;&nbsp;下面仅给出不同的部分：

```JavaScript
server.get("/api/users", (req, res) => {
  fetch("http://example.com/api/users") // 转发给目标服务器
    .then((res) => res.json()) // 将response对象转换为json对象
    .then((data) => { // 接收json对象
      console.log("Forwarded success!");
      res.setHeader("Access-Control-Allow-Origin", req.get("Origin"));
      res.send(data); // 转发json对象
    })
    .catch((err) => {
      console.log(err);
      res.send(err);
    });
});
```

&nbsp;&nbsp;&nbsp;&nbsp;第6行设置转发给前端的响应头，添加CORS策略支持，其中`req.get("Origin")`为发起请求的网站源服务器，以允许请求源进行跨域访问。或者将第二个参数直接写改为前端所在域名＋端口，让其独享本api。当然了，也可以直接设置反向代理使专属api与网站同源。
